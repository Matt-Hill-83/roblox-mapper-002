# F007 - Harness Code Categorization - Tasks

## Task List

1. ⬛ T1: Repository Setup
   1. ⬛ T1.1: Clone Harness repository
   2. ⬛ T1.2: Create script directory structure
   3. ⬛ T1.3: Set up file scanning infrastructure

2. ⬛ T2: Initial Repository Analysis
   1. ⬛ T2.1: Scan repository structure
   2. ⬛ T2.2: Identify service boundaries
   3. ⬛ T2.3: Catalog component types
   4. ⬛ T2.4: Document initial findings

3. ⬛ T3: Property Schema Design
   1. ⬛ T3.1: Define 5 properties based on analysis
   2. ⬛ T3.2: Ensure minimum 5 categories per property
   3. ⬛ T3.3: Create JSON schema definition
   4. ⬛ T3.4: Validate schema with sample data

4. ⬛ T4: Full Repository Scan
   1. ⬛ T4.1: Implement property extractors
   2. ⬛ T4.2: Process files and extract metadata
   3. ⬛ T4.3: Generate 200 file objects
   4. ⬛ T4.4: Export as JSON dataset

5. ⬛ T5: Data Validation
   1. ⬛ T5.1: Verify 200 objects generated
   2. ⬛ T5.2: Confirm property distribution
   3. ⬛ T5.3: Validate category counts
   4. ⬛ T5.4: Generate summary report

6. ⬛ T6: Codebase Integration Analysis
   1. ✅ T6.1: Find the file in the codebase that generates object data
   2. ✅ T6.2: Determine what the created data looks like
   3. ✅ T6.3: Determine how the link data is created
   4. ✅ T6.4: Change the code to read the data from a .ts file
   5. ✅ T6.5: Determine if the code is agnostic to the data type and can handle our data
   6. ✅ T6.6: Pass in a sample of our data

7. ✅ T7: Test Data Preparation
   1. ✅ T7.1: Create a file called tempHarnessTestData.ts
   2. ✅ T7.2: Read the first 120 lines of harness-files.json and recreate that data in the new temp file

8. ✅ T8: Code Analysis Documentation
   1. ✅ T8.1: Create a doc called 000 - petType usage in code.md
   2. ✅ T8.2: Find everywhere in the code petType exists, and determine which of those are live code vs dead code
   3. ✅ T8.3: Note: The code may be tightly coupled to the old data structure


9. ⬛ T9: Make Axis Filters Dynamic
   1. ⬛ T9.1: Create property discovery system that reads all properties from data objects
   2. ⬛ T9.2: Remove hardcoded "type" and "petType" property assignments
   3. ⬛ T9.3: Implement dynamic property assignment:
      1. ⬛ T9.3.1: Assign first discovered property to Z axis by default
      2. ⬛ T9.3.2: Assign second discovered property to X axis by default
   4. ⬛ T9.4: Update GUI axis mapping controls to show all available properties
   5. ⬛ T9.5: Enable real-time property selection for each axis in the GUI
   6. ⬛ T9.6: Ensure code is fully data-type agnostic
   
   Note: Previously the data was a set of Person objects with hardcoded "type" and "petType" properties. This task adapts the code to work with any data structure.

10. ✅ T10: Z-Parallel Shadow Lane Length Standardization
    1. ✅ T10.1: Find the code that creates the z-parallel shadow lane lengths
    2. ✅ T10.2: Make them all the same length
    3. ✅ T10.3: Note the order of creation:
       1. Nodes and node swimlanes
       2. Z parallel shadows


11. ✅ T11: Unify Labels on Shadow Blocks
    1. ✅ T11.1: Find all label creation code for swimlane shadow blocks
    2. ✅ T11.2: Identify the different border width implementations
    3. ✅ T11.3: Create a common utility or constants for label styling
    4. ✅ T11.4: Update all label creation to use the unified approach